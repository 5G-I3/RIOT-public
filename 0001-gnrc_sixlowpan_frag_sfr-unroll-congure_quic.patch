From ea70571d45e773b02c2a346a62de7dd66da241e5 Mon Sep 17 00:00:00 2001
From: Martine Lenders <m.lenders@fu-berlin.de>
Date: Wed, 26 May 2021 14:13:54 +0200
Subject: [PATCH] gnrc_sixlowpan_frag_sfr: unroll congure_quic

---
 .../net/gnrc/sixlowpan/frag/sfr/congure.h     | 335 ++++++++++--------
 .../net/gnrc/sixlowpan/frag/sfr_types.h       |  67 +++-
 2 files changed, 262 insertions(+), 140 deletions(-)

diff --git a/sys/include/net/gnrc/sixlowpan/frag/sfr/congure.h b/sys/include/net/gnrc/sixlowpan/frag/sfr/congure.h
index 071b2cf002..ac037888d8 100644
--- a/sys/include/net/gnrc/sixlowpan/frag/sfr/congure.h
+++ b/sys/include/net/gnrc/sixlowpan/frag/sfr/congure.h
@@ -24,6 +24,7 @@
 #include "congure.h"
 #include "kernel_defines.h"
 #include "net/gnrc/sixlowpan/frag/sfr.h"
+#include "ztimer.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -34,56 +35,6 @@ extern "C" {
  */
 #define GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT    (1U)
 
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) || DOXYGEN
-/**
- * @brief   Retrieve CongURE state object from a pool of free objects
- *
- * Needs to be defined in for a each CongURE implementation `congure_x` e.g. as
- * a sub-module `gnrc_sixlowpan_frag_sfr_congure_x` and call the respective
- * `congure_x_snd_setup` function when a free object is available for that
- * object. As such, congure_snd_t::driver == NULL can be used as an identifier
- * if a state object is free.
- *
- * The pool of objects has to have an initial size of at least
- * @ref CONFIG_GNRC_SIXLOWPAN_FRAG_FB_SIZE.
- *
- * The window unit is @ref GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT.
- *
- * @return  A CongURE state object on success
- * @return  NULL, if no free CongURE state object is available (including when
- *          when module `gnrc_sixlowpan_frag_sfr_congure` is not included).
- */
-congure_snd_t *gnrc_sixlowpan_frag_sfr_congure_snd_get(void);
-#else
-static inline congure_snd_t *gnrc_sixlowpan_frag_sfr_congure_snd_get(void)
-{
-    return NULL;
-}
-#endif
-
-/**
- * @brief   Frees the CongURE state object
- *
- * This makes a CongURE state object retrievable with
- * @ref gnrc_sixlowpan_frag_sfr_congure_snd_get again.
- *
- * @pre CongURE object is not NULL when called with module
- *      `gnrc_sixlowpan_frag_sfr_congure` used.
- *
- * @param[in] c     A CongURE state object
- *
- * @note    Does not do anything without the module
- *          `gnrc_sixlowpan_frag_sfr_congure`
- */
-static inline void gnrc_sixlowpan_frag_sfr_congure_snd_free(congure_snd_t *c)
-{
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    c->driver = NULL;
-#else
-    (void)c;
-#endif
-}
-
 /**
  * @brief   Frees the CongURE state object of a fragmentation buffer and set's
  *          it to `NULL`
@@ -96,53 +47,159 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_free(congure_snd_t *c)
 static inline void gnrc_sixlowpan_frag_sfr_congure_snd_destroy(gnrc_sixlowpan_frag_fb_t *fb)
 {
 #if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    gnrc_sixlowpan_frag_sfr_congure_snd_free(fb->sfr.congure);
-    fb->sfr.congure = NULL;
+    fb->sfr.cwnd = 0;
 #else
     (void)fb;
 #endif
 }
 
 /**
- * @brief   Initializes a CongURE state object in a fragmentation buffer entry
+ * @brief   Retrieve CongURE state object when not retrieved and initialize it
+ *          for a fragmentation buffer entry
  *
  * @param[in] fb    A fragmentation buffer entry
  *
  * @note    Does not do anything without the module
  *          `gnrc_sixlowpan_frag_sfr_congure`
  */
-static inline void gnrc_sixlowpan_frag_sfr_congure_snd_init(gnrc_sixlowpan_frag_fb_t *fb)
+static inline void gnrc_sixlowpan_frag_sfr_congure_snd_setup(gnrc_sixlowpan_frag_fb_t *fb)
 {
 #if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    fb->sfr.congure->driver->init(fb->sfr.congure, fb);
+    if (fb->sfr.cwnd == 0) {
+        fb->sfr.first_rtt_sample = 0;
+        fb->sfr.cwnd = CONFIG_GNRC_SIXLOWPAN_SFR_OPT_WIN_SIZE;
+        fb->sfr.in_flight_size = 0U;
+        fb->sfr.recovery_start = 0U;
+        fb->sfr.ssthresh = CONGURE_WND_SIZE_MAX;
+        fb->sfr.limited = 0U;
+        fb->sfr.max_ack_delay = 0U;
+        fb->sfr.smoothed_rtt = 333U;
+        fb->sfr.rtt_var = 333U / 2U;
+        fb->sfr.min_rtt = 0U;
+    }
 #else
     (void)fb;
 #endif
 }
 
-/**
- * @brief   Retrieve CongURE state object when not retrieved and initialize it
- *          for a fragmentation buffer entry
- *
- * @param[in] fb    A fragmentation buffer entry
- *
- * @note    Does not do anything without the module
- *          `gnrc_sixlowpan_frag_sfr_congure`
- */
-static inline void gnrc_sixlowpan_frag_sfr_congure_snd_setup(gnrc_sixlowpan_frag_fb_t *fb)
+static inline int _in_recov(gnrc_sixlowpan_frag_fb_t *fb, ztimer_now_t sent_time)
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    if (fb->sfr.congure == NULL) {
-        fb->sfr.congure = gnrc_sixlowpan_frag_sfr_congure_snd_get();
-        assert(fb->sfr.congure);
-        gnrc_sixlowpan_frag_sfr_congure_snd_init(fb);
-        if (fb->sfr.congure->cwnd > CONFIG_GNRC_SIXLOWPAN_SFR_MAX_WIN_SIZE) {
-            fb->sfr.congure->cwnd = CONFIG_GNRC_SIXLOWPAN_SFR_MAX_WIN_SIZE;
+    return sent_time <= fb->sfr.recovery_start;
+}
+
+static inline void _on_congestion_event(gnrc_sixlowpan_frag_fb_t *fb, ztimer_now_t sent_time)
+{
+    if (_in_recov(fb, sent_time)) {
+        return;
+    }
+    /* enter congestion recovery period */
+    fb->sfr.recovery_start = ztimer_now(ZTIMER_MSEC);
+    fb->sfr.ssthresh = (fb->sfr.cwnd * 1U) / 2;
+    fb->sfr.cwnd = (fb->sfr.ssthresh > CONFIG_GNRC_SIXLOWPAN_SFR_MIN_WIN_SIZE)
+                    ? fb->sfr.ssthresh : CONFIG_GNRC_SIXLOWPAN_SFR_MIN_WIN_SIZE;
+}
+
+static inline void _update_rtts(gnrc_sixlowpan_frag_fb_t *fb, ztimer_now_t msg_send_time,
+                                ztimer_now_t ack_recv_time, uint16_t ack_delay)
+{
+    uint16_t latest_rtt;
+
+    assert((ack_recv_time - msg_send_time) <= UINT16_MAX);
+    /* we assume that is in the uint16_t range, but just in case NDEBUG
+     * is set, let's cap it at UINT16_MAX */
+    if ((ack_recv_time - msg_send_time) > UINT16_MAX) {
+        latest_rtt = UINT16_MAX;
+    }
+    else {
+        latest_rtt = ack_recv_time - msg_send_time;
+    }
+
+    if (fb->sfr.first_rtt_sample > 0) {
+        fb->sfr.min_rtt = (fb->sfr.min_rtt > latest_rtt) ? latest_rtt : fb->sfr.min_rtt;
+        /* adjust latest_rtt for ack_delay if plausible */
+        if (latest_rtt > (fb->sfr.min_rtt + ack_delay)) {
+            latest_rtt -= ack_delay;
+        }
+        fb->sfr.rtt_var = ((3U * fb->sfr.rtt_var) / 4U) +
+                     /* abs(fb->sfr.smoothed_rtt - latest_rtt) / 4 */
+                     (((fb->sfr.smoothed_rtt > latest_rtt)
+                       ? (fb->sfr.smoothed_rtt - latest_rtt)
+                       : (latest_rtt - fb->sfr.smoothed_rtt)) / 4U);
+        fb->sfr.smoothed_rtt = ((7U * fb->sfr.smoothed_rtt) / 8U) + (latest_rtt / 8U);
+    }
+    else {
+        fb->sfr.min_rtt = latest_rtt;
+        fb->sfr.smoothed_rtt = latest_rtt;
+        fb->sfr.rtt_var = latest_rtt / 2;
+        fb->sfr.first_rtt_sample = ztimer_now(ZTIMER_MSEC);
+    }
+}
+
+static inline void _reset_cwnd(gnrc_sixlowpan_frag_fb_t *fb, congure_snd_msg_t *msgs)
+{
+    /* Reset the congestion window if the loss of these packets indicates
+     * persistent congestion. Only consider packets sent after getting an RTT
+     * sample */
+    if (fb->sfr.first_rtt_sample > 0U) {
+        /* XXX need to untangle clist_foreach() to add to lost and remove
+         * elements from `msgs` in-place (using prev and next) */
+        congure_snd_msg_t *ptr = (congure_snd_msg_t *)msgs->super.next;
+
+        /* untangle clist_foreach, since there is no easy
+         * way to provide both `lost` and `c` to the handler function */
+        if (ptr) {
+            ztimer_now_t latest = 0U;
+            ztimer_now_t earliest =
+                ((congure_snd_msg_t *)ptr->super.next)->send_time;
+            uint32_t pc_duration;   /* use uint32_t here to prevent overflows */
+            uint16_t rtt_var = (4 * fb->sfr.rtt_var);
+
+            if (rtt_var > 1) {
+                rtt_var = 1;
+            }
+
+            pc_duration = (fb->sfr.smoothed_rtt + rtt_var + fb->sfr.max_ack_delay) *
+                          3000;
+
+            do {
+                ptr = (congure_snd_msg_t *)ptr->super.next;
+                if (ptr->send_time > fb->sfr.first_rtt_sample) {
+                    /* consider for persistent congestion */
+                    if (latest < ptr->send_time) {
+                        latest = ptr->send_time;
+                    }
+                    if (earliest > ptr->send_time) {
+                        earliest = ptr->send_time;
+                    }
+                    if ((latest - earliest) > pc_duration) {
+                        /* in persistent congestion */
+                        fb->sfr.cwnd = CONFIG_GNRC_SIXLOWPAN_SFR_MIN_WIN_SIZE;
+                        if (fb->sfr.ssthresh < CONFIG_GNRC_SIXLOWPAN_SFR_MIN_WIN_SIZE) {
+                            /* See
+                             * https://github.com/quicwg/base-drafts/issues/4826#issuecomment-776305871
+                             * XXX: this differs from the pseudo-code in
+                             * Appendix B.8, where when `ssthresh` is lower than
+                             * `cwnd` (e.g. because )
+                             */
+                            fb->sfr.ssthresh = CONFIG_GNRC_SIXLOWPAN_SFR_MIN_WIN_SIZE;
+                        }
+                        fb->sfr.recovery_start = 0;
+                    }
+                }
+            } while ((&ptr->super) != msgs->super.next);
         }
     }
-#else
-    (void)fb;
-#endif
+}
+
+static inline void _dec_flight_size(gnrc_sixlowpan_frag_fb_t *fb)
+{
+    /* check for integer underflow */
+    if ((fb->sfr.in_flight_size - 1) > fb->sfr.in_flight_size) {
+        fb->sfr.in_flight_size = 0U;
+    }
+    else {
+        fb->sfr.in_flight_size--;
+    }
 }
 
 /**
@@ -164,7 +221,7 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_setup(gnrc_sixlowpan_frag
 static inline bool gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(gnrc_sixlowpan_frag_fb_t *fb)
 {
 #if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    return fb->sfr.frags_sent < fb->sfr.congure->cwnd;
+    return fb->sfr.frags_sent < fb->sfr.cwnd;
 #else
     return fb->sfr.frags_sent < CONFIG_GNRC_SIXLOWPAN_SFR_OPT_WIN_SIZE;
 #endif
@@ -190,7 +247,7 @@ static inline bool gnrc_sixlowpan_frag_sfr_congure_snd_next_in_cwnd(gnrc_sixlowp
 {
 #if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
     return (fb->sfr.frags_sent + GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT)
-        < fb->sfr.congure->cwnd;
+        < fb->sfr.cwnd;
 #else
     return (fb->sfr.frags_sent + GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT)
         < CONFIG_GNRC_SIXLOWPAN_SFR_OPT_WIN_SIZE;
@@ -235,22 +292,9 @@ static inline uint32_t gnrc_sixlowpan_frag_sfr_congure_snd_inter_frame_gap(
         gnrc_sixlowpan_frag_fb_t *fb
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    if (fb != NULL) {
-        congure_snd_t *c = fb->sfr.congure;
-        int32_t res = c->driver->inter_msg_interval(
-            c, GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT
-        );
-
-        if ((res >= 0) &&
-            ((unsigned)res >= CONFIG_GNRC_SIXLOWPAN_SFR_INTER_FRAME_GAP_US)) {
-            return (uint32_t)res;
-        }
-    }
-#else
-    (void)fb;
-#endif
-    return CONFIG_GNRC_SIXLOWPAN_SFR_INTER_FRAME_GAP_US;
+    /* interval in QUIC spec is a divisor, so flip denominator and numerator;
+     * smoothed_rtt is in ms, but expected result is in us */
+    return (4 * fb->sfr.smoothed_rtt * US_PER_MS) / (5 * fb->sfr.cwnd);
 }
 
 /**
@@ -268,13 +312,16 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(
         gnrc_sixlowpan_frag_fb_t *fb
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    congure_snd_t *c = fb->sfr.congure;
-
-    c->driver->report_msg_sent(c, GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT);
-#else
-    (void)fb;
-#endif
+    if ((fb->sfr.in_flight_size + 1) < fb->sfr.cwnd) {
+        fb->sfr.in_flight_size++;
+    }
+    else {
+        /* state machine is dependent on flight size being smaller or equal
+         * to cwnd as such cap cwnd here, in case caller reports a message in
+         * flight that was marked as lost, but the caller is using a later
+         * message to send another ACK. */
+        fb->sfr.in_flight_size = fb->sfr.cwnd;
+    }
 }
 
 /**
@@ -292,13 +339,31 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_discard(
         gnrc_sixlowpan_frag_fb_t *fb
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    congure_snd_t *c = fb->sfr.congure;
+    assert(1 <= fb->sfr.in_flight_size);
 
-    c->driver->report_msg_discarded(c, GNRC_SIXLOWPAN_FRAG_SFR_CONGURE_UNIT);
-#else
-    (void)fb;
-#endif
+    _dec_flight_size(fb);
+}
+
+static inline void _snd_report_msgs_lost(gnrc_sixlowpan_frag_fb_t *fb,
+                                         congure_snd_msg_t *frags)
+{
+    /* XXX need to untangle clist_foreach() to record last_lost_sent */
+    congure_snd_msg_t *ptr = (congure_snd_msg_t *)frags->super.next;
+    ztimer_now_t last_lost_sent = 0U;
+
+    if (ptr) {
+        do {
+            ptr = (congure_snd_msg_t *)ptr->super.next;
+            _dec_flight_size(fb);
+            if (last_lost_sent < ptr->send_time) {
+                last_lost_sent = ptr->send_time;
+            }
+        } while ((&ptr->super) != frags->super.next);
+    }
+    if (last_lost_sent) {
+        _on_congestion_event(fb, last_lost_sent);
+    }
+    _reset_cwnd(fb, frags);
 }
 
 /**
@@ -316,13 +381,7 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(
         gnrc_sixlowpan_frag_fb_t *fb
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    congure_snd_t *c = fb->sfr.congure;
-
-    c->driver->report_msgs_timeout(c, (congure_snd_msg_t *)(&fb->sfr.window));
-#else
-    (void)fb;
-#endif
+    _snd_report_msgs_lost(fb, (congure_snd_msg_t *)(&fb->sfr.window));
 }
 
 /**
@@ -342,14 +401,7 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_lost(
         gnrc_sixlowpan_frag_fb_t *fb, congure_snd_msg_t *frags
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    congure_snd_t *c = fb->sfr.congure;
-
-    c->driver->report_msgs_lost(c, frags);
-#else
-    (void)fb;
-    (void)frags;
-#endif
+    _snd_report_msgs_lost(fb, frags);
 }
 
 /**
@@ -371,18 +423,30 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_acked(
         congure_snd_ack_t *ack
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    congure_snd_t *c = fb->sfr.congure;
+    _dec_flight_size(fb);
 
-    c->driver->report_msg_acked(c, frag, ack);
-    if (c->cwnd > CONFIG_GNRC_SIXLOWPAN_SFR_MAX_WIN_SIZE) {
-        c->cwnd = CONFIG_GNRC_SIXLOWPAN_SFR_MAX_WIN_SIZE;
+    /* https://tools.ietf.org/html/draft-ietf-quic-recovery-34#appendix-A.7 */
+    if ((frag->size > 0) && (ack->recv_time > 0)) {
+        _update_rtts(fb, frag->send_time, ack->recv_time, ack->delay);
+    }
+    /* Do not increase congestion_window if application limited or flow control
+     * limited. */
+    if (fb->sfr.limited) {
+        return;
+    }
+
+    /* do not change congestion window in recovery period */
+    if (_in_recov(fb, frag->send_time)) {
+        return;
+    }
+    if (fb->sfr.cwnd < fb->sfr.ssthresh) {
+        /* in slow start mode */
+        fb->sfr.cwnd += frag->size;
+    }
+    else {
+        /* congestion avoidance */
+        fb->sfr.cwnd += frag->size / fb->sfr.cwnd;
     }
-#else
-    (void)fb;
-    (void)frag;
-    (void)ack;
-#endif
 }
 
 /**
@@ -402,14 +466,7 @@ static inline void gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(
         gnrc_sixlowpan_frag_fb_t *fb, uint32_t time
     )
 {
-#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
-    congure_snd_t *c = fb->sfr.congure;
-
-    c->driver->report_ecn_ce(c, (ztimer_now_t)time);
-#else
-    (void)fb;
-    (void)time;
-#endif
+    _on_congestion_event(fb, time);
 }
 
 #ifdef __cplusplus
diff --git a/sys/include/net/gnrc/sixlowpan/frag/sfr_types.h b/sys/include/net/gnrc/sixlowpan/frag/sfr_types.h
index d2f417ddd4..9767c7224c 100644
--- a/sys/include/net/gnrc/sixlowpan/frag/sfr_types.h
+++ b/sys/include/net/gnrc/sixlowpan/frag/sfr_types.h
@@ -46,7 +46,72 @@ typedef union {
  */
 typedef struct gnrc_sixlowpan_frag_sfr_fb {
 #if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) || DOXYGEN
-    congure_snd_t *congure;     /**< state object for [CongURE](@ref sys_congure) */
+    /**
+     * @brief   Timestamp in milliseconds of when the first RTT sample was
+     *          obtained
+     */
+    ztimer_now_t first_rtt_sample;
+
+    /**
+     * @brief   Sum of caller-defined units of message sizes of all messages
+     *          that are yet not ack'd or declared lost
+     */
+    unsigned in_flight_size;
+
+    /**
+     * @brief   Timestamp in milliseconds of when congestion was first detected.
+     *
+     * This is the time when congestion recovery mode is entered.
+     */
+    ztimer_now_t recovery_start;
+    congure_wnd_size_t cwnd;        /**< Congestion window size */
+
+    /**
+     * @brief   Slow start threshold in caller-defined units.
+     *
+     * When congure_quic_snd_t::cwnd is below congure_quic_snd_t::ssthresh the
+     * algorithm is in slow start mode and congure_quic_snd_t::cwnd grows in
+     * number of caller-defined units of acknowledged messages sizes
+     */
+    congure_wnd_size_t ssthresh;
+
+    /**
+     * @brief   The smoothed RTT of a connection between peers in milliseconds
+     */
+    uint16_t smoothed_rtt;
+
+    /**
+     * @brief   The RTT variation
+     */
+    uint16_t rtt_var;
+
+    /**
+     * @brief   The minimum RTT seen over a period of time
+     */
+    uint16_t min_rtt;
+
+    /**
+     * @brief   Set to one if congestion control should is limited by the
+     *          application or flow control
+     *
+     * Should be supplied and may be changed by user before calling a @ref
+     * sys_congure function.
+     *
+     * @see https://tools.ietf.org/html/draft-ietf-quic-recovery#appendix-B.5
+     */
+    uint16_t limited;
+
+    /**
+     * @brief   Advertised maximum amount of time in milliseconds a receiver
+     *          intends to delay its acknowledgements
+     *
+     * Used to establish persistent congestion.
+     *
+     * Should be supplied and may be changed by user before calling a @ref
+     * sys_congure function. If this value is not provided by the * protocol,
+     * leave it at 0.
+     */
+    uint16_t max_ack_delay;
 #endif
     /**
      * @brief   Acknowledgment request timeout event
-- 
2.31.1

